{"version":3,"sources":["../../src/fs/index.js"],"names":["require","debug","useCache","promisify","fn","name","fnCall","args","arguments","resolve","reject","apply","concat","err","fnargs","slice","cacheCall","disableFSCache","exists","dir","stat","String","indexOf","mkdir","openFile","open","readdir","readFile","writeFile","tmpFile","file","fdpath","fd","tmpFileSync","fileSync","mkdirp","directory","cwd","split","sep","mkdirpSync","mkdirSync"],"mappings":"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","file":"../../src/fs/index.js","sourcesContent":["/**\n * @file src/fs.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport tmp from 'tmp'\nimport path from 'path'\nimport { fn as wrap } from '../utils'\n\nconst { debug } = require('../utils/log')('hopp:fs')\n\nlet useCache = true\n\n/**\n * Similar to bluebird's Promise.promisify.\n * @param {Function} fn the async-callback function to transform\n * @return {Function} a new promise-based function\n */\nfunction promisify (fn, name) {\n  /**\n   * Create function call wrapper.\n   */\n  const fnCall = function () {\n    const args = [...arguments]\n\n    debug('%s(%j)', name, args)\n    return new Promise((resolve, reject) => {\n      fn.apply(this, args.concat([function (err) {\n        const fnargs = [...arguments]\n\n        if (err) reject(err)\n        else resolve.apply(null, fnargs.slice(1))\n      }]))\n    })\n  }\n\n  /**\n   * Create deterministic wrapper.\n   */\n  const cacheCall = wrap(fnCall)\n\n  /**\n   * Return conditional cache.\n   */\n  return function () {\n    const args = [...arguments]\n\n    if (useCache) return cacheCall.apply(this, args)\n    return fnCall.apply(this, args)\n  }\n}\n\n/**\n * Allow disabling of cache.\n */\nexport const disableFSCache = () => {\n  debug('Disabling fs cache')\n  useCache = false\n}\n\n/**\n * Transform only needed methods (instead of using mz\n * or doing a promisifyAll).\n */\nexport const exists = async dir => {\n  try {\n    await stat(dir)\n    return true\n  } catch (err) {\n    if (String(err).indexOf('ENOENT') === -1) {\n      throw err\n    }\n\n    return false\n  }\n}\nexport const stat = promisify(fs.stat, 'stat')\nexport const mkdir = promisify(fs.mkdir, 'mkdir')\nexport const openFile = promisify(fs.open, 'open')\nexport const readdir = promisify(fs.readdir, 'readdir')\nexport const readFile = promisify(fs.readFile, 'readFile')\nexport const writeFile = promisify(fs.writeFile, 'writeFile')\n\n/**\n * Create temporary file.\n */\nexport const tmpFile = () => new Promise((resolve, reject) => {\n  tmp.file((err, fdpath, fd) => {\n    if (err) reject(err)\n    else resolve([fd, fdpath])\n  })\n})\n\n/**\n * Create temporary file (sync).\n */\nexport const tmpFileSync = () => tmp.fileSync()\n\n/**\n * mkdir -p\n */\nexport const mkdirp = wrap(async (directory, cwd) => {\n  // explode into separate\n  directory = directory.split(path.sep)\n\n  // walk\n  for (let dir of directory) {\n    if (dir) {\n      try {\n        await mkdir(cwd + path.sep + dir)\n      } catch (err) {\n        if (String(err).indexOf('EEXIST') === -1) {\n          throw err\n        }\n      }\n    }\n\n    cwd += path.sep + dir\n  }\n})\n\n/**\n * mkdir -p (sync)\n */\nexport const mkdirpSync = (directory, cwd) => {\n  // explode into separate\n  directory = directory.split(path.sep)\n\n  // walk\n  for (let dir of directory) {\n    if (dir) {\n      try {\n        debug('mkdirp(%s)', cwd + path.sep + dir)\n        fs.mkdirSync(cwd + path.sep + dir)\n      } catch (err) {\n        if (String(err).indexOf('EEXIST') === -1) {\n          throw err\n        }\n      }\n    }\n\n    cwd += path.sep + dir\n  }\n}\n"]}