{"version":3,"sources":["../src/cache.js"],"names":["require","version","debug","log","lock","createCache","v","p","load","directory","Error","lockfile","process","env","RECACHE","JSON","parse","_","updateCache","val","key","value","undefined","plugin","plugins","hasOwnProperty","pluginName","sourcemap","taskName","sm","save","stringify","gt","compat","default","err"],"mappings":"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","file":"../src/cache.js","sourcesContent":["/**\n * @file src/cache/load.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport { existsSync, readFileSync, writeFileSync } from 'fs'\n\nconst { version } = require('../package.json')\nconst { debug, log } = require('./utils/log')('hopp')\nlet lock\n\n/**\n * Define what an empty cache looks like.\n */\nconst createCache = () => ((lock = {\n  v: version,\n  p: {}\n}))\n\n/**\n * Loads a cache from the project.\n * @param {String} directory project directory\n * @return {Object} the loaded cache\n */\nexport const load = directory => {\n  // send back internal cache if reloading\n  if (lock) return lock\n\n  // verify directory\n  if (typeof directory !== 'string' || !existsSync(directory)) {\n    throw new Error('Invalid directory given: ' + directory)\n  }\n\n  // set cache file\n  const lockfile = `${directory}/hopp.lock`\n\n  // bring cache into existence\n  if (process.env.RECACHE === 'true' || !existsSync(lockfile)) {\n    return (lock = createCache())\n  }\n\n  // load lock file\n  debug('Loading cache')\n  try {\n    lock = JSON.parse(readFileSync(lockfile, 'utf8'))\n    debug('loaded cache at v%s', lock.v)\n  } catch (_) {\n    log('Corrupted cache; ejecting.')\n    return (lock = createCache())\n  }\n\n  // handle version change\n  if (lock.v !== version) {\n    log('Found stale cache; updating.')\n    return updateCache(lock)\n  }\n\n  return lock\n}\n\n/**\n * Adds/replaces a value in the cache.\n * @param {String} key\n * @param {Any} value anything stringifiable\n * @returns {Any?} value from cache\n */\nexport const val = (key, value) => {\n  if (value === undefined) {\n    return lock[key]\n  }\n\n  lock[key] = value\n}\n\n/**\n * Load/create cache for a plugin.\n * @param {}\n */\nexport const plugin = pluginName => {\n  const plugins = val('p')\n\n  if (!plugins.hasOwnProperty(pluginName)) {\n    plugins[pluginName] = {}\n  }\n\n  return plugins[pluginName]\n}\n\n/**\n * Get/set a sourcemap.\n * @param {String} taskName name of the task\n * @param {Object} sm sourcemap to save for the task\n * @returns {Object} sourcemap from cache\n */\nexport const sourcemap = (taskName, sm) => {\n  let sourcemap = val('sm')\n\n  if (!sourcemap) {\n    val('sm', sourcemap = {})\n  }\n\n  if (sm) {\n    sourcemap[taskName] = sm\n  } else {\n    sourcemap[taskName] = sourcemap[taskName] || {}\n  }\n\n  return sourcemap\n}\n\n/**\n * Saves the lockfile again.\n * @param {*} directory\n */\nexport const save = directory => {\n  debug('Saving cache')\n  writeFileSync(directory + '/hopp.lock', JSON.stringify(lock))\n}\n\n/**\n * Cache updater.\n */\nfunction updateCache (lock) {\n  // handle newer lock files\n  if (require('semver').gt(lock.v, version)) {\n    throw new Error('Sorry, this project was built with a newer version of hopp. Please upgrade hopp by running: npm i -g hopp')\n  }\n\n  let compat\n\n  // load converter\n  try {\n    compat = require('./compat/' + lock.v).default\n  } catch (err) {\n    compat = require('./compat/else').default\n  }\n\n  // do convert\n  return compat(lock)\n}\n"]}