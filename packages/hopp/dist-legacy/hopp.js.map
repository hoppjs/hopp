{"version":3,"sources":["../src/hopp.js"],"names":["require","debug","normalize","name","normalized","i","length","toUpperCase","createMethod","type","plugName","method","directory","args","arguments","d","stack","push","preset","resolve","substack","apply","forEach","row","plugins","indexOf","prototype","hasOwnProperty","Error","init","src","all","steps","watch"],"mappings":";;;;;;ypBAAA;;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;eAEkBA,QAAQ,aAAR,EAAuB,MAAvB,C;IAAVC,K,YAAAA,K;;AAER;;;;;;AAIA,SAASC,SAAT,CAAoBC,IAApB,EAA0B;AACxB,MAAIC,aAAa,EAAjB;;AAEA,OAAK,IAAIC,IAAI,EAAb,EAAiBA,IAAIF,KAAKG,MAA1B,EAAkCD,KAAK,CAAvC,EAA0C;AACxCD,kBAAcD,KAAKE,CAAL,MAAY,GAAZ,GAAkBF,KAAKE,GAAL,EAAUE,WAAV,EAAlB,GAA4CJ,KAAKE,CAAL,CAA1D;AACD;;AAED,SAAOD,UAAP;AACD;;AAED;;;;;;;;;AASA,SAASI,YAAT,CAAuBC,IAAvB,EAA6BN,IAA7B,EAAmCO,QAAnC,EAA6CC,MAA7C,EAAqDC,SAArD,EAAgE;AAC9D,SAAO,YAAY;AAAA;;AACjB,QAAMC,4CAAWC,SAAX,EAAN;;AAEA,QAAIL,SAAS,QAAb,EAAuB;AACrB,WAAKM,CAAL,CAAOC,KAAP,CAAaC,IAAb,CAAkB,CAChBd,IADgB,EAEhBU,IAFgB,EAGhBF,MAHgB,CAAlB;AAKD,KAND,MAMO;AACL,UAAMO,SAASlB,QAAQ,eAAKmB,OAAL,CAAaP,SAAb,EAAwB,cAAxB,EAAwCT,IAAxC,CAAR,CAAf;AACA,UAAMiB,WAAWF,OAAOG,KAAP,CAAa,IAAb,EAAmBR,IAAnB,CAAjB;;AAEAO,eAASE,OAAT,CAAiB,eAAO;AAAA,kCACPC,GADO;AAAA,YACfpB,IADe;;AAGtB,YAAIA,KAAK,CAAL,MAAY,GAAhB,EAAqB;AACnB,gBAAKY,CAAL,CAAOC,KAAP,CAAaC,IAAb,CAAkBM,GAAlB;AACD,SAFD,MAEO;AACL,gBAAKpB,IAAL,EAAWkB,KAAX,QAAuBE,IAAI,CAAJ,CAAvB;AACD;AACF,OARD;AASD;;AAED,WAAO,IAAP;AACD,GAzBD;AA0BD;;AAED;;;;kBAGe,qBAAa;AAC1B,MAAMC,UAAU,2BAAYZ,SAAZ,CAAhB;;AAEA,OAAK,IAAMT,IAAX,IAAmBqB,OAAnB,EAA4B;AAC1B,QAAMf,OAAON,KAAKsB,OAAL,CAAa,QAAb,MAA2B,CAAC,CAA5B,GAAgC,QAAhC,GAA2C,QAAxD;AACA,QAAMf,WAAWR,UAAUC,IAAV,CAAjB;;AAEAF,UAAM,oBAAN,EAA4BQ,IAA5B,EAAkCN,IAAlC,EAAwCO,QAAxC;;AAEA;AACA,QAAI,cAAKgB,SAAL,CAAeC,cAAf,CAA8BjB,QAA9B,CAAJ,EAA6C;AAC3C,YAAM,IAAIkB,KAAJ,CAAW,eAAcnB,IAAK,KAAIN,IAAK,KAAIO,QAAS,kBAApD,CAAN;AACD;;AAED;AACA;AACA;AACA,kBAAKgB,SAAL,CAAehB,QAAf,IAA2BF,aAAaC,IAAb,EAAmBN,IAAnB,EAAyBO,QAAzB,EAAmC,SAAnC,EAA8CE,SAA9C,CAA3B;;AAEA;AAhB0B;AAAA;AAAA;;AAAA;AAiB1B,2BAAqBY,QAAQrB,IAAR,CAArB,8HAAoC;AAAA,YAAzBQ,MAAyB;;AAClC,YAAIA,WAAW,YAAX,IAA2BA,WAAW,QAAtC,IAAkDA,WAAW,SAAjE,EAA4E;AAC1E,wBAAKe,SAAL,CAAehB,QAAf,EAAyBC,MAAzB,IAAmCH,aAAaC,IAAb,EAAmBN,IAAnB,EAAyBO,QAAzB,EAAmCC,MAAnC,EAA2CC,SAA3C,CAAnC;AACD;AACF;AArByB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsB3B;;AAED;;;AAGA,MAAMiB,OAAO,SAAPA,IAAO;AAAA,WAAO,kBAASC,GAAT,CAAP;AAAA,GAAb;;AAEAD,OAAKE,GAAL;AACAF,OAAKG,KAAL;AACAH,OAAKI,KAAL;;AAEA,SAAOJ,IAAP;AACD,C","file":"../src/hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport path from 'path'\nimport Hopp from './tasks/mgr'\nimport createSteps from './tasks/steps'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Normalizes a plugin/preset name to be added to\n * the prototype.\n */\nfunction normalize (name) {\n  let normalized = ''\n\n  for (let i = 12; i < name.length; i += 1) {\n    normalized += name[i] === '-' ? name[i++].toUpperCase() : name[i]\n  }\n\n  return normalized\n}\n\n/**\n * Generates a proxy method that allows all the plugin calls to be\n * cached.\n * \n * Instead of actually loading the plugin at this stage, we will just\n * pop its call into our internal call stack for use later. this is\n * useful when we are stepping through an entire hoppfile but might\n * only be running a single task.\n */\nfunction createMethod (type, name, plugName, method, directory) {\n  return function () {\n    const args = [...arguments]\n\n    if (type === 'plugin') {\n      this.d.stack.push([\n        name,\n        args,\n        method\n      ])\n    } else {\n      const preset = require(path.resolve(directory, 'node_modules', name))\n      const substack = preset.apply(null, args)\n\n      substack.forEach(row => {\n        const [name] = row\n\n        if (name[0] === '/') {\n          this.d.stack.push(row)\n        } else {\n          this[name].apply(this, row[1])\n        }\n      })\n    }\n\n    return this\n  }\n}\n\n/**\n * Create hopp object based on plugins.\n */\nexport default directory => {\n  const plugins = loadPlugins(directory)\n\n  for (const name in plugins) {\n    const type = name.indexOf('plugin') !== -1 ? 'plugin' : 'preset'\n    const plugName = normalize(name)\n\n    debug('adding %s %s as %s', type, name, plugName)\n\n    // check for conflicts\n    if (Hopp.prototype.hasOwnProperty(plugName)) {\n      throw new Error(`Conflicting ${type}: ${name} (${plugName} already exists)`)\n    }\n\n    // add the plugin to the hopp prototype so it can be\n    // used for the rest of the build process\n    // this function is the proxy of the 'default' function\n    Hopp.prototype[plugName] = createMethod(type, name, plugName, 'default', directory)\n\n    // add any other methods\n    for (const method of plugins[name]) {\n      if (method !== '__esModule' && method !== 'config' && method !== 'default') {\n        Hopp.prototype[plugName][method] = createMethod(type, name, plugName, method, directory)\n      }\n    }\n  }\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n\n  init.all = createParallel\n  init.steps = createSteps\n  init.watch = createWatch\n\n  return init\n}\n"]}