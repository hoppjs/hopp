{"version":3,"sources":["../src/hopp.js"],"names":["require","debug","normalize","name","normalized","i","length","toUpperCase","createMethod","type","plugName","method","directory","d","stack","push","slice","call","arguments","preset","resolve","substack","apply","forEach","row","plugins","hasOwnProperty","indexOf","prototype","Error","init","src","all","steps","watch"],"mappings":"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","file":"../src/hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport path from 'path'\nimport Hopp from './tasks/mgr'\nimport createSteps from './tasks/steps'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Normalizes a plugin/preset name to be added to\n * the prototype.\n */\nfunction normalize (name) {\n  let normalized = ''\n\n  for (let i = 12; i < name.length; i += 1) {\n    normalized += name[i] === '-' ? name[i++].toUpperCase() : name[i]\n  }\n\n  return normalized\n}\n\n/**\n * Generates a proxy method that allows all the plugin calls to be\n * cached.\n * \n * Instead of actually loading the plugin at this stage, we will just\n * pop its call into our internal call stack for use later. this is\n * useful when we are stepping through an entire hoppfile but might\n * only be running a single task.\n */\nfunction createMethod (type, name, plugName, method, directory) {\n  return function () {\n    if (type === 'plugin') {\n      this.d.stack.push([\n        name,\n        [].slice.call(arguments),\n        method\n      ])\n    } else {\n      const preset = require(path.resolve(directory, 'node_modules', name))\n      const substack = preset.apply(null, arguments)\n\n      substack.forEach(row => {\n        const [name] = row\n\n        if (name[0] === '/') {\n          this.d.stack.push(row)\n        } else {\n          this[name].apply(this, row[1])\n        }\n      })\n    }\n\n    return this\n  }\n}\n\n/**\n * Create hopp object based on plugins.\n */\nexport default directory => {\n  const plugins = loadPlugins(directory)\n\n  for (const name in plugins) {\n    if (plugins.hasOwnProperty(name)) {\n      const type = name.indexOf('plugin') !== -1 ? 'plugin' : 'preset'\n      const plugName = normalize(name)\n\n      debug('adding %s %s as %s', type, name, plugName)\n\n      // check for conflicts\n      if (Hopp.prototype.hasOwnProperty(plugName)) {\n        throw new Error(`Conflicting ${type}: ${name} (${plugName} already exists)`)\n      }\n\n      // add the plugin to the hopp prototype so it can be\n      // used for the rest of the build process\n      // this function is the proxy of the 'default' function\n      Hopp.prototype[plugName] = createMethod(type, name, plugName, 'default', directory)\n\n      // add any other methods\n      for (const method of plugins[name]) {\n        if (method !== '__esModule' && method !== 'config' && method !== 'default') {\n          Hopp.prototype[plugName][method] = createMethod(type, name, plugName, method, directory)\n        }\n      }\n    }\n  }\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n\n  init.all = createParallel\n  init.steps = createSteps\n  init.watch = createWatch\n\n  return init\n}\n"]}