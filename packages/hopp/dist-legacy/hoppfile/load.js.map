{"version":3,"sources":["../../src/hoppfile/load.js"],"names":["cache","file","Error","lmod","mtime","state","Object","create","val","tasks","require","bustedTasks","task","hasOwnProperty","json","toJSON","Array","test","resolve"],"mappings":";;;;;;ypBAAA;;;;;;AAMA;;IAAYA,K;;AACZ;;AACA;;;;kBAEe,gBAAQ;AACrB;AACA,MAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAIC,KAAJ,CAAU,mBAAV,CAAN;AACD;;AAED;AACA,MAAMC,OAAO,CAAC,kBAASF,IAAT,EAAeG,KAA7B;;AAEA;AACA,MAAMC,QAAQC,OAAOC,MAAP,CAAc,IAAd,CAAd;AAVqB,aAWQP,MAAMQ,GAAN,CAAU,GAAV,KAAkB,EAX1B;;AAAA;;AAWnBH,QAAMF,IAXa;AAWPE,QAAMI,KAXC;;;AAarB,MAAIJ,MAAMF,IAAN,KAAeA,IAAnB,EAAyB;AACvB,WAAO,CAAC,IAAD,EAAOG,OAAOC,MAAP,CAAc,IAAd,CAAP,EAA4BF,MAAMI,KAAlC,CAAP;AACD;;AAED;AACA,MAAMA,QAAQC,QAAQT,IAAR,CAAd;;AAEA;AACAI,QAAMI,KAAN,GAAcJ,MAAMI,KAAN,IAAe,EAA7B;AACA,MAAME,cAAc,EAApB;;AAEA;AACA,OAAK,IAAIC,IAAT,IAAiBH,KAAjB,EAAwB;AACtB,QAAIJ,MAAMI,KAAN,CAAYI,cAAZ,CAA2BD,IAA3B,CAAJ,EAAsC;AACpC,UAAME,OAAOL,MAAMG,IAAN,EAAYG,MAAZ,EAAb;;AAEA,UAAI,EAAED,gBAAgBE,KAAlB,KAA4B,CAAC,sBAAUF,IAAV,EAAgBT,MAAMI,KAAN,CAAYG,IAAZ,CAAhB,CAAjC,EAAqE;AACnED,oBAAYC,IAAZ,IAAoB,IAApB;AACD;AACF;AACF;;AAED;AACAZ,QAAMQ,GAAN,CACE,GADF,EAGE,cAAcS,IAAd,CAAmB,sBAAaP,QAAQQ,OAAR,CAAgBjB,IAAhB,CAAb,EAAoC,MAApC,CAAnB;;AAEA;AAFA,IAGI,CACA,CADA,EAEA,IAFA;;AAKF;AARF,IASI,CACAE,IADA,EAEAM,KAFA,CAZN;;AAkBA;AACA,SAAO,CAAC,KAAD,EAAQE,WAAR,EAAqBF,KAArB,CAAP;AACD,C","file":"../../src/hoppfile/load.js","sourcesContent":["/**\n * @file src/utils/load.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport * as cache from '../cache'\nimport { deepEqual } from '../utils'\nimport { statSync, readFileSync } from 'fs'\n\nexport default file => {\n  // if bad args die\n  if (typeof file !== 'string') {\n    throw new Error('Unknown arguments')\n  }\n\n  // get file stat\n  const lmod = +statSync(file).mtime\n\n  // try to load from cache\n  const state = Object.create(null)\n  ;[state.lmod, state.tasks] = cache.val('_') || []\n\n  if (state.lmod === lmod) {\n    return [true, Object.create(null), state.tasks]\n  }\n\n  // load via require\n  const tasks = require(file)\n\n  // figure out which tasks are bust\n  state.tasks = state.tasks || {}\n  const bustedTasks = {}\n\n  // only try checking for single tasks\n  for (let task in tasks) {\n    if (state.tasks.hasOwnProperty(task)) {\n      const json = tasks[task].toJSON()\n\n      if (!(json instanceof Array) && !deepEqual(json, state.tasks[task])) {\n        bustedTasks[task] = true\n      }\n    }\n  }\n\n  // cache exports\n  cache.val(\n    '_',\n\n    /function|=>/.test(readFileSync(require.resolve(file), 'utf8'))\n\n    // if any functions exist, we can't cache the file\n      ? [\n        0,\n        null\n      ]\n\n      // otherwise, cache normally\n      : [\n        lmod,\n        tasks\n      ]\n  )\n\n  // return exports\n  return [false, bustedTasks, tasks]\n}\n"]}