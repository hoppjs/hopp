{"version":3,"sources":["../../src/streams/bundle.js"],"names":["Bundle","directory","fd","target","createWriteStream","autoClose","map","Object","create","offset","files","sizes","status","buffers","flushIndex","id","Math","random","goal","file","stream","push","on","Buffer","isBuffer","d","body","from","length","resolve","reject","flush","then","relative","replace","write","concat","close"],"mappings":"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","file":"../../src/streams/bundle.js","sourcesContent":["/**\n * @file src/streams/bundle.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport { EventEmitter } from 'events'\n\nexport default class Bundle extends EventEmitter {\n  constructor (directory, fd) {\n    super()\n\n    this.target = fs.createWriteStream(null, {\n      fd,\n      autoClose: false\n    })\n\n    this.map = Object.create(null)\n    this.offset = 0\n    this.files = []\n    this.sizes = Object.create(null)\n    this.status = Object.create(null)\n    this.buffers = Object.create(null)\n    this.flushIndex = 0\n    this.id = Math.random()\n    this.directory = directory\n\n    this.goal = []\n  }\n\n  add (file, stream) {\n    this.files.push(file)\n    this.buffers[file] = []\n    this.sizes[file] = 0\n    this.status[file] = false\n\n    stream.on('data', d => {\n      // in case it got stringified\n      if (!Buffer.isBuffer(d.body)) {\n        d.body = Buffer.from(d.body)\n      }\n\n      this.sizes[file] += d.body.length\n      this.buffers[file].push(d.body)\n    })\n\n    this.goal.push(new Promise((resolve, reject) => {\n      stream.on('error', reject)\n      stream.on('end', () => {\n        this.status[file] = true\n        this.flush().then(resolve, reject)\n      })\n    }))\n  }\n\n  /**\n   * Flush, in order.\n   */\n  async flush () {\n    const file = this.files[this.flushIndex]\n    const relative = file.replace(this.directory, '.')\n\n    if (this.status[file] && !this.map[relative]) {\n      // record sourcemap\n      this.map[relative] = [this.offset, this.offset + this.sizes[file]]\n      this.offset += this.sizes[file]\n\n      // write to file\n      await new Promise(resolve => {\n        this.target.write(Buffer.concat(this.buffers[file]), resolve)\n      })\n\n      // move to next\n      this.flushIndex++\n    }\n  }\n\n  end () {\n    return Promise.all(this.goal).then(async () => {\n      /**\n       * Ensure all data has been written.\n       */\n      while (this.flushIndex < this.files.length) {\n        await this.flush()\n      }\n\n      /**\n       * Close the bundle.\n       */\n      this.target.close()\n    })\n  }\n}\n"]}