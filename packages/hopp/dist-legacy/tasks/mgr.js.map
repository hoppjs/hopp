{"version":3,"sources":["../../src/tasks/mgr.js"],"names":["cache","debug","watchlog","log","plugins","pluginConfig","isUndefined","value","undefined","Hopp","src","Array","pluginCtx","d","stack","rename","plugin","method","hasOwnProperty","bind","out","dest","mapper","Error","push","filename","dirname","source","applyRename","basename","ext","substr","lastIndexOf","prefix","suffix","name","directory","recache","watchers","forEach","newpath","resolve","nonMagic","watch","recursive","indexOf","start","process","on","watcher","close","modified","useDoubleCache","sourcemap","files","freshBuild","unmodified","file","originalFd","tmpBundle","tmpBundlePath","bundle","Date","now","stream","createReadStream","fd","autoClose","replace","end","concat","buildStack","add","reject","pipe","createWriteStream","map","that","mode","_","pluginStream","obj","data","done","handler","retval","next","taskName","args","mod","pathToPlugin","join","require","err","config","logger","pluginCache","error","safeTimeout","setTimeout","exit","needsBundling","needsRecaching","readonly","length","loadedPlugins","loadPlugin","env","SKIP_BUILD","startBundling","clearTimeout","outfile","doRename","body","output","tmp","tmppath","promise","newStream","resolved","then","val","json"],"mappings":"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","file":"../../src/tasks/mgr.js","sourcesContent":["/**\n * @file src/tasks/mgr.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport path from 'path'\nimport pump from 'pump'\nimport glob from '../fs/glob'\nimport through2 from 'through2'\nimport * as cache from '../cache'\nimport getPath from '../fs/get-path'\nimport { _, createLogger } from '../utils'\nimport { buffer, Bundle, createReadStream, map as mapStream } from '../streams'\nimport { disableFSCache, mkdirp, mkdirpSync, openFile, tmpFile, tmpFileSync } from '../fs'\n\nconst { debug } = createLogger('hopp')\nconst watchlog = createLogger('hopp:watch').log\n\n/**\n * Plugins storage.\n */\nconst plugins = {}\nconst pluginConfig = {}\n\n/**\n * Test for undefined or null.\n */\nfunction isUndefined (value) {\n  return value === undefined || value === null\n}\n\n/**\n * Hopp class to manage tasks.\n */\nexport default class Hopp {\n  /**\n   * Creates a new task with the glob.\n   * DOES NOT START THE TASK.\n   *\n   * @param {Glob} src\n   * @return {Hopp} new hopp object\n   */\n  constructor (src) {\n    if (!(src instanceof Array)) {\n      src = [src]\n    }\n\n    // store context local to each task\n    this.pluginCtx = {}\n\n    // persistent info\n    this.d = {\n      src,\n      stack: [],\n      rename: []\n    }\n\n    // bind all plugin extras\n    for (const plugin in this) {\n      if (typeof this[plugin] === 'function') {\n        for (const method in this[plugin]) {\n          if (this[plugin].hasOwnProperty(method)) {\n            this[plugin][method] = this[plugin][method].bind(this)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the destination of this pipeline.\n   * @param {String} out\n   * @return {Hopp} task manager\n   */\n  dest (out) {\n    this.d.dest = out\n    return this\n  }\n\n  /**\n   * Allow renaming of destination files.\n   * @param {Object|Function} mapper renaming options or renaming function\n   * @returns {Hopp} current object for chaining\n   */\n  rename (mapper) {\n    if (typeof mapper !== 'function' && typeof mapper !== 'object') {\n      throw new Error('Rename must be given a function or object.')\n    }\n\n    this.d.rename.push(mapper)\n    return this\n  }\n\n  /**\n   * Actually do the renaming.\n   * @param {String} filename the original name\n   * @param {String} dirname the destination directory\n   * @param {String} source the absolute source filename\n   * @returns {String} renamed filename\n   */\n  doRename (filename, dirname, source) {\n    let dest = dirname + '/' + filename\n\n    for (const mapper of this.d.rename) {\n      dest = this.applyRename(mapper, path.basename(dest), path.dirname(dest), source)\n    }\n\n    return dest\n  }\n\n  /**\n   * Apply a single rename.\n   * @param {Object|Function} mapper renaming object or function\n   * @param {String} filename the original name\n   * @param {String} dirname the destination directory\n   * @param {String} source the absolute source filename\n   * @returns {String} renamed filename\n   */\n  applyRename (mapper, filename, dirname, source) {\n    // if no rename is defined, just use current filename\n    if (!mapper) return dirname + '/' + filename\n\n    // functions are easy, but they break caching\n    if (typeof mapper === 'function') {\n      return mapper(filename, dirname, source)\n    }\n\n    // remove extension\n    let ext = filename.substr(1 + filename.lastIndexOf('.'))\n    filename = filename.substr(0, filename.lastIndexOf('.'))\n\n    // add prefix\n    if (mapper.prefix) {\n      filename = mapper.prefix + filename\n    }\n\n    // add suffix, before extension\n    if (mapper.suffix) {\n      filename += mapper.suffix\n    }\n\n    // change extension\n    if (mapper.ext) {\n      ext = mapper.ext\n    }\n\n    // output final filename into same dest directory\n    return dirname + '/' + filename + '.' + ext\n  }\n\n  /**\n   * Run task in continuous mode.\n   */\n  watch (name, directory, recache = false) {\n    name = `watch:${name}`\n\n    const watchers = []\n\n    this.d.src.forEach(src => {\n      // get most definitive path possible\n      let newpath = path.resolve(directory, glob.nonMagic(src))\n\n      // disable fs caching for watch\n      disableFSCache()\n\n      // start watch\n      watchlog('Watching for %s ...', name)\n      watchers.push(fs.watch(newpath, {\n        recursive: src.indexOf('/**/') !== -1\n      }, () => this.start(name, directory, recache, false)))\n    })\n\n    return new Promise(resolve => {\n      process.on('SIGINT', () => {\n        watchers.forEach(watcher => watcher.close())\n        resolve()\n      })\n    })\n  }\n\n  /**\n   * Handles bundling.\n   */\n  async startBundling (name, directory, modified, dest, useDoubleCache = true) {\n    const { log, debug } = createLogger(`hopp:${name}`)\n    debug('Switched to bundling mode')\n\n    /**\n     * Fetch sourcemap from cache.\n     */\n    const sourcemap = cache.sourcemap(name)\n\n    /**\n     * Get full list of current files.\n     */\n    const files = await glob(name, this.d.src, directory, useDoubleCache, true)\n\n    /**\n     * Create list of unmodified.\n     */\n    let freshBuild = true\n    const unmodified = {}\n\n    for (let file of files) {\n      if (modified.indexOf(file) === -1) {\n        unmodified[file] = true\n        freshBuild = false\n      }\n    }\n\n    /**\n     * Get old bundle & create new one.\n     */\n    const originalFd = freshBuild ? null : await openFile(dest, 'r')\n    const [tmpBundle, tmpBundlePath] = await tmpFile()\n\n    /**\n     * Create new bundle to forward to.\n     */\n    const bundle = new Bundle(directory, tmpBundle)\n\n    /**\n     * Since bundling starts streaming right away, we can count this\n     * as the start of the build.\n     */\n    const start = Date.now()\n    log('Starting task')\n\n    /**\n     * Add all files.\n     */\n    for (let file of files) {\n      let stream\n\n      if (unmodified[file]) {\n        debug('forward: %s', file)\n        stream = fs.createReadStream(null, {\n          fd: originalFd,\n          autoClose: false,\n          start: sourcemap[file.replace(directory, '.')].start,\n          end: sourcemap[file.replace(directory, '.')].end\n        })\n      } else {\n        debug('transform: %s', file)\n        stream = pump([\n          createReadStream(file, dest + '/' + path.basename(file))\n        ].concat(this.buildStack(name)))\n      }\n\n      bundle.add(file, stream)\n    }\n\n    /**\n     * Wait for bundling to end.\n     */\n    await bundle.end(tmpBundlePath)\n\n    /**\n     * Move the bundle to the new location.\n     */\n    if (originalFd) originalFd.close()\n    await mkdirp(path.dirname(dest).replace(directory, ''), directory)\n    await new Promise((resolve, reject) => {\n      const stream = fs.createReadStream(tmpBundlePath).pipe(fs.createWriteStream(dest))\n\n      stream.on('close', resolve)\n      stream.on('error', reject)\n    })\n\n    /**\n     * Update sourcemap.\n     */\n    cache.sourcemap(name, bundle.map)\n\n    log('Task ended (took %s ms)', Date.now() - start)\n  }\n\n  /**\n   * Converts all plugins in the stack into streams.\n   */\n  buildStack (name) {\n    const that = this\n\n    let mode = 'stream'\n\n    return this.d.stack.map(([plugin, _, method]) => {\n      const pluginStream = through2.obj(async function (data, _, done) {\n        try {\n          /**\n           * Try and get proper method - assume\n           * default by default.\n           */\n          const handler = plugins[plugin][method || 'default'](\n            that.pluginCtx[plugin],\n            data\n          )\n\n          // for async functions/promises\n          if ('then' in handler) {\n            try {\n              this.push(await handler)\n              done()\n            } catch (err) {\n              done(err)\n            }\n          } else if ('next' in handler) {\n            let retval\n\n            // for async generators\n            do {\n              retval = await handler.next()\n              this.push(retval.value)\n            } while (!retval.done)\n\n            done()\n          } else {\n            // otherwise, fail\n            done(new Error('Unknown return value received from ' + plugin))\n          }\n        } catch (err) {\n          done(err)\n        }\n      })\n\n      /**\n       * Enable buffer mode if required.\n       */\n      if (mode === 'stream' && pluginConfig[plugin].mode === 'buffer') {\n        mode = 'buffer'\n        return pump(buffer(), pluginStream)\n      }\n\n      /**\n       * Otherwise keep pumping.\n       */\n      return pluginStream\n    })\n  }\n\n  /**\n   * Loads a plugin, manages its env.\n   */\n  loadPlugin (taskName, plugin, args, directory) {\n    let mod = plugins[plugin]\n\n    if (!mod) {\n      // convert plugin path from relative back to absolute\n      try {\n        let pathToPlugin = plugin\n\n        if (plugin[0] !== '/') {\n          pathToPlugin = path.join(directory, 'node_modules', plugin)\n        }\n\n        mod = require(pathToPlugin)\n      } catch (err) {\n        debug('failed to load plugin: %s', err && err.stack ? err.stack : err)\n        throw new Error('Failed to load plugin: ' + plugin)\n      }\n\n      // expose module config\n      pluginConfig[plugin] = mod.config || {}\n\n      // add plugins to loaded plugins\n      plugins[plugin] = mod\n    }\n\n    // create plugin logger\n    const logger = createLogger(`hopp:${taskName}:${path.basename(plugin).substr(5)}`)\n\n    // load/create cache for plugin\n    const pluginCache = cache.plugin(plugin)\n\n    // create a new context for this plugin\n    this.pluginCtx[plugin] = {\n      args,\n      cache: pluginCache,\n      log: logger.log,\n      debug: logger.debug,\n      error: logger.error\n    }\n  }\n\n  /**\n   * Starts the pipeline.\n   * @return {Promise} resolves when task is complete\n   */\n  async start (name, directory, recache = false, useDoubleCache = true) {\n    const { log, debug, error } = createLogger(`hopp:${name}`)\n\n    /**\n     * Add timeout for safety.\n     */\n    const safeTimeout = setTimeout(() => {\n      error('Timeout exceeded! Task was hung.')\n      process.exit(-1)\n    }, 6e4)\n\n    /**\n     * Figure out if bundling is needed & load plugins.\n     */\n    if (isUndefined(this.needsBundling) || isUndefined(this.needsRecaching) || isUndefined(this.readonly) || (this.d.stack.length > 0 && !this.loadedPlugins)) {\n      this.loadedPlugins = true\n\n      this.d.stack.forEach(([plugin, args]) => {\n        if (!this.pluginCtx.hasOwnProperty(plugin)) {\n          this.loadPlugin(name, plugin, args, directory)\n        }\n\n        this.needsBundling = !!(this.needsBundling || pluginConfig[plugin].bundle)\n        this.needsRecaching = !!(this.needsRecaching || pluginConfig[plugin].recache)\n        this.readonly = !!(this.readonly || pluginConfig[plugin].readonly)\n\n        if (this.needsBundling && this.readonly) {\n          throw new Error('Task chain enabled bundling and readonly mode at the same time. Not sure what to do.')\n        }\n      })\n    }\n\n    /**\n     * Override recaching.\n     */\n    if (this.needsRecaching) {\n      recache = true\n    }\n\n    /**\n     * Get the modified files.\n     */\n    debug('task recache = %s', recache)\n    let files = await glob(name, this.d.src, directory, useDoubleCache, recache)\n\n    /**\n     * Quit now if we want to build skipping.\n     */\n    if (process.env.SKIP_BUILD === 'true') {\n      log('Updated cache')\n      return\n    }\n\n    if (files.length > 0) {\n      const dest = this.d.dest ? path.resolve(directory, getPath(this.d.dest)) : ''\n\n      /**\n       * Switch to bundling mode if need be.\n       */\n      if (this.needsBundling) {\n        await this.startBundling(name, directory, files, dest, useDoubleCache)\n        clearTimeout(safeTimeout)\n        return\n      }\n\n      /**\n       * Ensure dist directory exists.\n       */\n      if (!this.readonly || !this.d.dest) {\n        await mkdirp(dest.replace(directory, ''), directory)\n      }\n\n      /**\n       * Create streams.\n       */\n      files = _(files).map(file => {\n        const outfile = this.doRename(path.basename(file), dest, file)\n\n        return {\n          file,\n          outfile,\n          stream: [\n            createReadStream(file, outfile)\n          ]\n        }\n      })\n\n      /**\n       * Connect plugin streams with pipelines.\n       */\n      if (this.d.stack.length > 0) {\n        files.map(file => {\n          file.stream = file.stream.concat(this.buildStack(name))\n          return file\n        })\n      }\n\n      /**\n       * Connect with destination.\n       */\n      files.map(file => {\n        if (!this.readonly) {\n          // strip out the actual body and write it\n          file.stream.push(mapStream((data, next) => {\n            if (typeof data !== 'object' || !data.hasOwnProperty('body')) {\n              return next(new Error('A plugin has destroyed the stream by returning a non-object.'))\n            }\n\n            next(null, data.body)\n          }))\n\n          // add the writestream at the end\n          let output\n\n          if (!this.d.dest) {\n            const { fd: tmp, name: tmppath } = tmpFileSync()\n            output = fs.createWriteStream(null, {\n              fd: tmp\n            })\n\n            file.promise = new Promise((resolve, reject) => {\n              output.on('close', () => {\n                const newStream =\n                  fs.createReadStream(tmppath)\n                    .pipe(fs.createWriteStream(file.file))\n\n                newStream.on('error', reject)\n                newStream.on('close', resolve)\n              })\n            })\n          } else {\n            debug('Set output: %s', file.outfile)\n            mkdirpSync(path.dirname(file.outfile).replace(directory, ''), directory)\n            output = fs.createWriteStream(file.outfile)\n          }\n\n          file.stream.push(output)\n        }\n\n        // promisify the current pipeline\n        return new Promise((resolve, reject) => {\n          let resolved = false\n\n          // connect all streams together to form pipeline\n          file.stream = pump(file.stream, err => {\n            if (err) reject(err)\n            else if (!resolved && !file.promise) resolve()\n          })\n\n          if (file.promise) {\n            file.promise.then(() => {\n              resolved = true\n              resolve()\n            }, reject)\n          }\n        })\n      })\n\n      // start & wait for all pipelines to end\n      const start = Date.now()\n      log('Starting task for %s files', files.length)\n      await Promise.all(files.val())\n      log('Task ended (took %s ms)', Date.now() - start)\n\n      // clear the timeout\n      clearTimeout(safeTimeout)\n    } else {\n      log('Skipping task')\n    }\n  }\n\n  /**\n   * Converts task manager to JSON for storage.\n   * @return {Object} proper JSON object\n   */\n  toJSON () {\n    return {\n      d: this.d,\n      needsBundling: this.needsBundling,\n      needsRecaching: this.needsRecaching,\n      readonly: this.readonly\n    }\n  }\n\n  /**\n   * Deserializes a JSON object into a manager.\n   * @param {Object} json\n   * @return {Hopp} task manager\n   */\n  fromJSON (json) {\n    this.d = json.d\n    this.needsBundling = json.needsBundling\n    this.needsRecaching = json.needsRecaching\n    this.readonly = json.readonly\n\n    return this\n  }\n}\n"]}