{"version":3,"sources":["../../src/tasks/parallel.js"],"names":["MAX_JOBS","cpus","length","debug","taskTree","bustedTasks","runParallel","jobs","tasks","name","directory","resolve","reject","isMaster","i","fork","JOB_START","JOB_SIZE","tasksPerJob","Math","floor","ndone","on","id","code","Error","min","FIRST_JOB","parseInt","process","env","LAST_JOB","subtasks","slice","runAsync","then","exit","catch","console","error","err","stack","map","runTask","task","indexOf","start","parallel","WEB_CONCURRENCY","isNaN","watch","toJSON","defineTasks","defns","busted"],"mappings":"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","file":"../../src/tasks/parallel.js","sourcesContent":["/**\n * @file src/plugins/parallel.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport os from 'os'\nimport cluster from 'cluster'\nimport { createLogger } from '../utils'\n\nconst MAX_JOBS = os.cpus().length\nconst { debug } = createLogger('hopp')\n\nlet taskTree\nlet bustedTasks\n\n/**\n * Run all tasks in parallel.\n */\nfunction runParallel (jobs, tasks, name, directory) {\n  return new Promise((resolve, reject) => {\n    if (cluster.isMaster) {\n      if (tasks.length < jobs) {\n        debug('starting %s jobs, 1 task per job', tasks.length)\n\n        for (let i = 0; i < tasks.length; i++) {\n          cluster.fork({\n            JOB_START: i,\n            JOB_SIZE: 1\n          })\n        }\n      } else {\n        const tasksPerJob = Math.floor(tasks.length / jobs)\n        debug('starting %s jobs, %s tasks per job', jobs, tasksPerJob)\n\n        // start all but last job\n        for (let i = 0; i < jobs; i++) {\n          cluster.fork({\n            JOB_START: i * tasksPerJob,\n            JOB_SIZE: i === MAX_JOBS - 1 ? MAX_JOBS - (tasksPerJob * (i - 1)) : tasksPerJob\n          })\n        }\n      }\n\n      // wait for the end of all the jobs\n      let ndone = 0\n\n      cluster.on('exit', (id, code) => {\n        ndone++\n\n        // if any worker fails, reject the promise\n        if (code !== 0) {\n          return reject(new Error(`Job ${id} failed.`))\n        }\n\n        // once all workers successfully return, resolve promise\n        if (ndone === Math.min(tasks.length, jobs)) {\n          resolve()\n        }\n      })\n    } else {\n      const FIRST_JOB = parseInt(process.env.JOB_START, 10)\n      const LAST_JOB = parseInt(process.env.JOB_START, 10) + parseInt(process.env.JOB_SIZE, 10)\n\n      // grab slice of tasks that this worker should do\n      const subtasks = tasks.slice(FIRST_JOB, LAST_JOB)\n\n      // run in async\n      runAsync(subtasks, name, directory)\n        .then(() => process.exit(0))\n        .catch(err => {\n          console.error(err && err.stack ? err.stack : err)\n          process.exit(-1)\n        })\n    }\n  })\n}\n\n/**\n * Run all tasks in async.\n */\nfunction runAsync (tasks, name, directory) {\n  // just async for now\n  debug('running %s tasks in async', tasks.length)\n  return Promise.all(tasks.map(\n    task => runTask(task, name, directory)\n  ))\n}\n\n/**\n * Run individual task.\n */\nfunction runTask (task, name, directory) {\n  if (task.indexOf(':') !== -1) {\n    throw new Error('You cannot use `:` in a task name. It is a restricted token.')\n  }\n\n  return taskTree[task].start(`${name}:${task}`, directory, !!bustedTasks[task])\n}\n\n/**\n * Creates a Hopp-ish object that runs\n * subtasks in parallel.\n */\nconst parallel = tasks => ({\n  /**\n   * Starts all tasks concurrently.\n   *\n   * @return {Promise} joins all task promises under .all()\n   */\n  start (name, directory) {\n    let jobs = parseInt(process.env.WEB_CONCURRENCY)\n\n    // if jobs not specified, just stick to async\n    if (isNaN(jobs)) return runAsync(tasks, name, directory)\n\n    // disallow negatives\n    if (jobs < 0) throw new Error('Negative number of jobs not supported.')\n\n    // if zero, assume max\n    if (jobs === 0) jobs = MAX_JOBS\n\n    // run parallel\n    return runParallel(jobs, tasks, name, directory)\n  },\n\n  /**\n   * Watch all subtasks.\n   */\n  watch (name, directory) {\n    return Promise.all(tasks.map(task => {\n      if (task.indexOf(':') !== -1) {\n        throw new Error('You cannot use `:` in a task name. It is a restricted token.')\n      }\n\n      return taskTree[task].watch(name + ':' + task, directory)\n    }))\n  },\n\n  /**\n   * Converts tasks to JSON.\n   * Just converts them into an tasksay of\n   * JSON objects.\n   *\n   * @return {tasksay}\n   */\n  toJSON () {\n    return ['parallel', tasks]\n  }\n})\n\nparallel.defineTasks = (defns, busted) => {\n  taskTree = defns\n  bustedTasks = busted\n}\n\nexport default parallel\n"]}