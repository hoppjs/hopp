{"version":3,"sources":["../src/hopp.js"],"names":["cache","debug","require","normalize","name","normalized","i","length","toUpperCase","createMethod","type","plugName","method","directory","args","arguments","d","stack","push","preset","resolve","substack","apply","forEach","row","addPlugin","plugins","indexOf","prototype","hasOwnProperty","Error","init","src","all","steps","watch","load","pathToPlugin","pluginName","_","basename","Object","keys"],"mappings":"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","file":"../src/hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport path from 'path'\nimport Hopp from './tasks/mgr'\nimport * as cache from './cache'\nimport createSteps from './tasks/steps'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Normalizes a plugin/preset name to be added to\n * the prototype.\n */\nfunction normalize (name) {\n  let normalized = ''\n\n  for (let i = 12; i < name.length; i += 1) {\n    normalized += name[i] === '-' ? name[i++].toUpperCase() : name[i]\n  }\n\n  return normalized\n}\n\n/**\n * Generates a proxy method that allows all the plugin calls to be\n * cached.\n * \n * Instead of actually loading the plugin at this stage, we will just\n * pop its call into our internal call stack for use later. this is\n * useful when we are stepping through an entire hoppfile but might\n * only be running a single task.\n */\nfunction createMethod (type, name, plugName, method, directory) {\n  return function () {\n    const args = [...arguments]\n\n    if (type === 'plugin') {\n      this.d.stack.push([\n        name,\n        args,\n        method\n      ])\n    } else {\n      const preset = require(path.resolve(directory, 'node_modules', name))\n      const substack = preset.apply(null, args)\n\n      substack.forEach(row => {\n        const [name] = row\n\n        if (name[0] === '/') {\n          this.d.stack.push(row)\n        } else {\n          this[name].apply(this, row[1])\n        }\n      })\n    }\n\n    return this\n  }\n}\n\n/**\n * Add single plugin to prototype.\n */\nfunction addPlugin (name, plugins, directory) {\n  const type = name.indexOf('plugin') !== -1 ? 'plugin' : 'preset'\n  const plugName = normalize(name)\n\n  debug('adding %s %s as %s', type, name, plugName)\n\n  // check for conflicts\n  if (Hopp.prototype.hasOwnProperty(plugName)) {\n    throw new Error(`Conflicting ${type}: ${name} (${plugName} already exists)`)\n  }\n\n  // add the plugin to the hopp prototype so it can be\n  // used for the rest of the build process\n  // this function is the proxy of the 'default' function\n  Hopp.prototype[plugName] = createMethod(type, name, plugName, 'default', directory)\n\n  // add any other methods\n  for (const method of plugins[name]) {\n    if (method !== '__esModule' && method !== 'config' && method !== 'default') {\n      Hopp.prototype[plugName][method] = createMethod(type, name, plugName, method, directory)\n    }\n  }\n}\n\n/**\n * Create hopp object based on plugins.\n */\nexport default directory => {\n  const plugins = loadPlugins(directory)\n\n  for (const name in plugins) {\n    addPlugin(name, plugins, directory)\n  }\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n\n  init.all = createParallel\n  init.steps = createSteps\n  init.watch = createWatch\n\n  /**\n   * API for loading local plugins.\n   */\n  init.load = function (pathToPlugin) {\n    debug('loading local plugin: %s', pathToPlugin)\n\n    // try and grab name from package.json\n    // otherwise use the directory's name\n    const pluginName = (() => {\n      try {\n        return require(pathToPlugin + '/package.json').name\n      } catch (_) {\n        return path.basename(pathToPlugin)\n      }\n    })()\n\n    // add to list\n    plugins[pluginName] = Object.keys(require(pathToPlugin))\n\n    // run normal add\n    addPlugin(pluginName, plugins, directory)\n  }\n\n  return init\n}\n"]}