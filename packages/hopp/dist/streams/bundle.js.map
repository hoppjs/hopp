{"version":3,"sources":["../../src/streams/bundle.js"],"names":["Bundle","constructor","directory","fd","target","createWriteStream","autoClose","map","Object","create","offset","files","sizes","status","buffers","flushIndex","id","Math","random","goal","add","file","stream","push","on","d","Buffer","isBuffer","body","from","length","resolve","reject","flush","then","relative","replace","write","concat","end","close"],"mappings":"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","file":"../../src/streams/bundle.js","sourcesContent":["/**\n * @file src/streams/bundle.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport { EventEmitter } from 'events'\n\nexport default class Bundle extends EventEmitter {\n  constructor (directory, fd) {\n    super()\n\n    this.target = fs.createWriteStream(null, {\n      fd,\n      autoClose: false\n    })\n\n    this.map = Object.create(null)\n    this.offset = 0\n    this.files = []\n    this.sizes = Object.create(null)\n    this.status = Object.create(null)\n    this.buffers = Object.create(null)\n    this.flushIndex = 0\n    this.id = Math.random()\n    this.directory = directory\n\n    this.goal = []\n  }\n\n  add (file, stream) {\n    this.files.push(file)\n    this.buffers[file] = []\n    this.sizes[file] = 0\n    this.status[file] = false\n\n    stream.on('data', d => {\n      // in case it got stringified\n      if (!Buffer.isBuffer(d.body)) {\n        d.body = Buffer.from(d.body)\n      }\n\n      this.sizes[file] += d.body.length\n      this.buffers[file].push(d.body)\n    })\n\n    this.goal.push(new Promise((resolve, reject) => {\n      stream.on('error', reject)\n      stream.on('end', () => {\n        this.status[file] = true\n        this.flush().then(resolve, reject)\n      })\n    }))\n  }\n\n  /**\n   * Flush, in order.\n   */\n  async flush () {\n    const file = this.files[this.flushIndex]\n    const relative = file.replace(this.directory, '.')\n\n    if (this.status[file] && !this.map[relative]) {\n      // record sourcemap\n      this.map[relative] = [this.offset, this.offset + this.sizes[file]]\n      this.offset += this.sizes[file]\n\n      // write to file\n      await new Promise(resolve => {\n        this.target.write(Buffer.concat(this.buffers[file]), resolve)\n      })\n\n      // move to next\n      this.flushIndex++\n    }\n  }\n\n  end () {\n    return Promise.all(this.goal).then(async () => {\n      /**\n       * Ensure all data has been written.\n       */\n      while (this.flushIndex < this.files.length) {\n        await this.flush()\n      }\n\n      /**\n       * Close the bundle.\n       */\n      this.target.close()\n    })\n  }\n}\n"]}