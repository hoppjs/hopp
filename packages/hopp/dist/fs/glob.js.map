{"version":3,"sources":["../../src/fs/glob.js"],"names":["task","pattern","cwd","useDoubleCache","recache","relative","pttn","directory","recursive","debug","slice","length","curr","shift","localResults","file","filepath","sep","relativepath","fstat","tempCache","retrievedCache","statCache","isFile","mtime","push","concat","walk","isDirectory","Array","gstatCache","undefined","cache","valOr","Object","create","process","env","RECACHE","results","Error","nm","glob","nonMagic","split","replace","substr","resolve","require","newpath","sub","indexOf"],"mappings":";;;;;;;;;sCAgBA,WAAqBA,IAArB,EAA2BC,OAA3B,EAAoCC,GAApC,EAAyCC,iBAAiB,KAA1D,EAAiEC,UAAU,KAA3E,EAAkF;;AA2BhF;;;AA3BgF;AAAA,2CA8BhF,WAAqBC,QAArB,EAA+BC,IAA/B,EAAqCC,SAArC,EAAgDC,YAAY,KAA5D,EAAmE;AACjEC,cAAM,4FAAN,EAAoGJ,QAApG,EAA8GC,IAA9G,EAAoHC,SAApH,EAA+HC,SAA/H,EAA0IN,GAA1I,EAA+IE,OAA/I,EAAwJE,KAAK,CAAL,CAAxJ;;AAEAA,eAAOA,KAAKI,KAAL,EAAP;;AAEA,YAAIJ,KAAKK,MAAL,KAAgB,CAApB,EAAuB;AACrB,iBAAO,EAAP;AACD;;AAED,cAAMC,OAAON,KAAKO,KAAL,EAAb;AACA,YAAIC,eAAe,EAAnB;;AAEA,aAAK,IAAIC,IAAT,IAAkB,6BAAM,eAAQR,SAAR,CAAN,CAAlB,EAA6C;AAC3C;AACA,gBAAMS,WAAWT,YAAY,eAAKU,GAAjB,GAAuBF,IAAxC;AACA,gBAAMG,eAAeb,WAAW,eAAKY,GAAhB,GAAsBF,IAA3C;;AAEA;AACA,cAAII,KAAJ;;AAEA,cAAIhB,cAAJ,EAAoB;AAClBgB,oBAAQC,UAAUJ,QAAV,IAAsBI,UAAUJ,QAAV,MAAuB,6BAAM,YAAKA,QAAL,CAAN,CAAvB,CAA9B;AACD,WAFD,MAEO;AACLG,oBAAQ,6BAAM,YAAKH,QAAL,CAAN,CAAR;AACD;;AAED;AACA,cAAIK,eAAeH,YAAf,CAAJ,EAAkC;AAChCI,sBAAUJ,YAAV,IAA0BG,eAAeH,YAAf,CAA1B;AACD;;AAEDT,gBAAM,yBAAN,EAAiCO,QAAjC,EAA2CJ,IAA3C,EAAiD,yBAAMG,IAAN,EAAYH,IAAZ,CAAjD,EAAoEO,MAAMI,MAAN,KAAiB,MAAjB,GAA0B,KAA9F;;AAEA;AACAd,gBAAM,gBAAN,EAAwB,CAACU,MAAMK,KAA/B,EAAsCF,UAAUJ,YAAV,CAAtC;;AAEA,cAAI,yBAAMH,IAAN,EAAYH,IAAZ,CAAJ,EAAuB;AACrB,gBAAIO,MAAMI,MAAN,EAAJ,EAAoB;AAClB,kBAAInB,WAAW,CAACkB,UAAUJ,YAAV,CAAZ,IAAuCI,UAAUJ,YAAV,MAA4B,CAACC,MAAMK,KAA9E,EAAqF;AACnFF,0BAAUJ,YAAV,IAA0B,CAACC,MAAMK,KAAjC;AACAV,6BAAaW,IAAb,CAAkBT,QAAlB;;AAEAP,sBAAM,SAAN,EAAiBO,QAAjB;AACD;AACF,aAPD,MAOO;AACLF,6BAAeA,aAAaY,MAAb,EAAoB,6BAAMC,KAAKT,YAAL,EAAmBZ,IAAnB,EAAyBU,QAAzB,EAAmCR,aAAaI,SAAS,IAAzD,CAAN,CAApB,EAAf;AACD;AACF,WAXD,MAWO,IAAIO,MAAMS,WAAN,MAAuBpB,SAA3B,EAAsC;AAC3CM,2BAAeA,aAAaY,MAAb,EAAoB,6BAAMC,KAAKT,YAAL,EAAmB,CAACN,IAAD,EAAOc,MAAP,CAAcpB,IAAd,CAAnB,EAAwCU,QAAxC,EAAkDR,SAAlD,CAAN,CAApB,EAAf;AACD;AACF;;AAED,eAAOM,YAAP;AACD,OAnF+E;;AAAA,sBA8BjEa,IA9BiE;AAAA;AAAA;AAAA;;AAqFhF;;;;;AApFA;AACA,QAAI,EAAE1B,mBAAmB4B,KAArB,CAAJ,EAAiC;AAC/B5B,gBAAU,CAACA,OAAD,CAAV;AACD;;AAED;AACA,QAAI6B,eAAeC,SAAnB,EAA8B;AAC5BD,mBAAaE,MAAMC,KAAN,CAAY,IAAZ,EAAkBC,OAAOC,MAAP,CAAc,IAAd,CAAlB,CAAb;AACD;;AAED;AACA,QAAIL,WAAW9B,IAAX,MAAqB+B,SAAzB,EAAoC;AAClCD,iBAAW9B,IAAX,IAAmBkC,OAAOC,MAAP,CAAc,IAAd,CAAnB;AACD;;AAED;AACA,QAAId,iBAAiBS,WAAW9B,IAAX,CAArB;AACA,QAAIsB,YAAYY,OAAOC,MAAP,CAAc,IAAd,CAAhB;;AAEA;AACA;AACAL,eAAW9B,IAAX,IAAmBsB,SAAnB;;AAEA;AACAlB,cAAUA,WAAWgC,QAAQC,GAAR,CAAYC,OAAZ,KAAwB,MAA7C,CA+DA,IAAIC,UAAU,EAAd;AACA,SAAK,IAAIjC,IAAT,IAAiBL,OAAjB,EAA0B;AACxB,UAAIK,KAAK,CAAL,MAAY,GAAhB,EAAqB;AACnB,cAAM,IAAIkC,KAAJ,CAAU,8CAAV,CAAN;AACD;;AAED,YAAMC,KAAKC,KAAKC,QAAL,CAAcrC,IAAd,CAAX;AACAG,YAAM,SAAN,EAAiBgC,EAAjB;;AAEA,UAAI,CAACA,EAAL,EAAS;AACPF,kBAAUA,QAAQb,MAAR,EAAe,6BAAMC,KAC7B,GAD6B,EAE7BrB,KAAKsC,KAAL,CAAW,GAAX,CAF6B,EAG7B1C,GAH6B,CAAN,CAAf,EAAV;AAKD,OAND,MAMO;AACLqC,kBAAUA,QAAQb,MAAR,EAAe,6BAAMC,KAC7Bc,EAD6B,EAE7BnC,KAAKuC,OAAL,CAAaJ,EAAb,EAAiB,EAAjB,EAAqBK,MAArB,CAA4B,CAA5B,EAA+BF,KAA/B,CAAqC,GAArC,CAF6B,EAG7B,eAAKG,OAAL,CAAa7C,GAAb,EAAkBuC,EAAlB,CAH6B,CAAN,CAAf,EAAV;AAKD;AACF;;AAED;;;AAGA,WAAOF,OAAP;AACD,G;;kBApHcG,I;;;;;AAsHf;;;;;;;AAhIA;;;;AACA;;;;AACA;;IAAYV,K;;AACZ;;;;;;AATA;;;;;;AAWA,MAAM,EAAEvB,KAAF,KAAYuC,QAAQ,cAAR,EAAwB,WAAxB,CAAlB;;AAEA,IAAIlB,UAAJ;AACA,MAAMV,YAAYc,OAAOC,MAAP,CAAc,IAAd,CAAlB;;AA6HAO,KAAKC,QAAL,GAAgB,UAAU1C,OAAV,EAAmB;AACjC,MAAIgD,UAAU,EAAd;;AAEA,OAAK,IAAIC,GAAT,IAAgBjD,QAAQ2C,KAAR,CAAc,GAAd,CAAhB,EAAoC;AAClC,QAAIM,GAAJ,EAAS;AACP,UAAIA,IAAIC,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CAA1B,EAA6B;AAC3B;AACD;;AAEDF,iBAAW,eAAKhC,GAAL,GAAWiC,GAAtB;AACD;AACF;;AAED,SAAOD,QAAQH,MAAR,CAAe,CAAf,CAAP;AACD,CAdD;;kBAgBeJ,I","file":"../../src/fs/glob.js","sourcesContent":["/**\n * @file src/glob.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport path from 'path'\nimport match from 'minimatch'\nimport * as cache from '../cache'\nimport { readdir, stat } from './'\n\nconst { debug } = require('../utils/log')('hopp:glob')\n\nlet gstatCache\nconst tempCache = Object.create(null)\n\nasync function glob (task, pattern, cwd, useDoubleCache = false, recache = false) {\n  // prefer arrays\n  if (!(pattern instanceof Array)) {\n    pattern = [pattern]\n  }\n\n  // ensure global cache is present\n  if (gstatCache === undefined) {\n    gstatCache = cache.valOr('sc', Object.create(null))\n  }\n\n  // create local cache\n  if (gstatCache[task] === undefined) {\n    gstatCache[task] = Object.create(null)\n  }\n\n  // create new local cache and load the retreived cache\n  let retrievedCache = gstatCache[task]\n  let statCache = Object.create(null)\n\n  // replace the retreived with new cache to get rid of stale\n  // entries\n  gstatCache[task] = statCache\n\n  // allow overrides from the env\n  recache = recache || process.env.RECACHE === 'true'\n\n  /**\n   * Recursive walk.\n   */\n  async function walk (relative, pttn, directory, recursive = false) {\n    debug('walk(relative = %s, pttn = %s, directory = %s, recursive = %s) in %s [recache:%s, curr:%s]', relative, pttn, directory, recursive, cwd, recache, pttn[0])\n\n    pttn = pttn.slice()\n\n    if (pttn.length === 0) {\n      return []\n    }\n\n    const curr = pttn.shift()\n    let localResults = []\n\n    for (let file of (await readdir(directory))) {\n      // fix file path\n      const filepath = directory + path.sep + file\n      const relativepath = relative + path.sep + file\n\n      // get stat from temp cache (for non-watch tasks) or stat()\n      let fstat\n\n      if (useDoubleCache) {\n        fstat = tempCache[filepath] = tempCache[filepath] || await stat(filepath)\n      } else {\n        fstat = await stat(filepath)\n      }\n\n      // pull from old cache, if it still exists\n      if (retrievedCache[relativepath]) {\n        statCache[relativepath] = retrievedCache[relativepath]\n      }\n\n      debug('match(%s,%s) => %s [%s]', filepath, curr, match(file, curr), fstat.isFile() ? 'file' : 'dir')\n\n      // has been modified\n      debug('stat(%s) :: %s', +fstat.mtime, statCache[relativepath])\n\n      if (match(file, curr)) {\n        if (fstat.isFile()) {\n          if (recache || !statCache[relativepath] || statCache[relativepath] !== +fstat.mtime) {\n            statCache[relativepath] = +fstat.mtime\n            localResults.push(filepath)\n\n            debug('add: %s', filepath)\n          }\n        } else {\n          localResults = localResults.concat(await walk(relativepath, pttn, filepath, recursive || curr === '**'))\n        }\n      } else if (fstat.isDirectory() && recursive) {\n        localResults = localResults.concat(await walk(relativepath, [curr].concat(pttn), filepath, recursive))\n      }\n    }\n\n    return localResults\n  }\n\n  /**\n   * Run all patterns against directory.\n   */\n  let results = []\n  for (let pttn of pattern) {\n    if (pttn[0] === '/') {\n      throw new Error('Not sure what to do with the / in your glob.')\n    }\n\n    const nm = glob.nonMagic(pttn)\n    debug('nm = %j', nm)\n\n    if (!nm) {\n      results = results.concat(await walk(\n        '.',\n        pttn.split('/'),\n        cwd\n      ))\n    } else {\n      results = results.concat(await walk(\n        nm,\n        pttn.replace(nm, '').substr(1).split('/'),\n        path.resolve(cwd, nm)\n      ))\n    }\n  }\n\n  /**\n   * Return final results object.\n   */\n  return results\n}\n\n/**\n * Get non-magical start of glob.\n * @param {String} pattern glob pattern\n * @returns {String} definitive path\n */\nglob.nonMagic = function (pattern) {\n  let newpath = ''\n\n  for (let sub of pattern.split('/')) {\n    if (sub) {\n      if (sub.indexOf('*') !== -1) {\n        break\n      }\n\n      newpath += path.sep + sub\n    }\n  }\n\n  return newpath.substr(1)\n}\n\nexport default glob\n"]}