{"version":3,"sources":["../../src/hoppfile/load.js"],"names":["cache","file","Error","lmod","mtime","state","tasks","val","require","bustedTasks","task","hasOwnProperty","json","toJSON","Array","test","resolve"],"mappings":";;;;;;AAMA;;IAAYA,K;;AACZ;;AACA;;;;kBAEe,MAAMC,IAAN,IAAc;AAC3B;AACA,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAIC,KAAJ,CAAU,mBAAV,CAAN;AACD;;AAED;AACA,QAAMC,OAAO,CAAC,CAAC,MAAM,cAAKF,IAAL,CAAP,EAAmBG,KAAjC;;AAEA;AACA,QAAMC,QAAQ,EAAd,CACC,CAACA,MAAMF,IAAP,EAAaE,MAAMC,KAAnB,IAA4BN,MAAMO,GAAN,CAAU,GAAV,KAAkB,EAA9C;;AAED,MAAIF,MAAMF,IAAN,KAAeA,IAAnB,EAAyB;AACvB,WAAO,CAAC,IAAD,EAAO,EAAP,EAAWE,MAAMC,KAAjB,CAAP;AACD;;AAED;AACA,QAAMA,QAAQE,QAAQP,IAAR,CAAd;;AAEA;AACAI,QAAMC,KAAN,GAAcD,MAAMC,KAAN,IAAe,EAA7B;AACA,QAAMG,cAAc,EAApB;;AAEA;AACA,OAAK,IAAIC,IAAT,IAAiBJ,KAAjB,EAAwB;AACtB,QAAIA,MAAMK,cAAN,CAAqBD,IAArB,KAA8BL,MAAMC,KAAN,CAAYK,cAAZ,CAA2BD,IAA3B,CAAlC,EAAoE;AAClE,YAAME,OAAON,MAAMI,IAAN,EAAYG,MAAZ,EAAb;;AAEA,UAAI,EAAED,gBAAgBE,KAAlB,KAA4B,CAAC,sBAAUF,IAAV,EAAgBP,MAAMC,KAAN,CAAYI,IAAZ,CAAhB,CAAjC,EAAqE;AACnED,oBAAYC,IAAZ,IAAoB,IAApB;AACD;AACF;AACF;;AAED;AACAV,QAAMO,GAAN,CACE,GADF,EAGE,cAAcQ,IAAd,EAAmB,MAAM,kBAASP,QAAQQ,OAAR,CAAgBf,IAAhB,CAAT,EAAgC,MAAhC,CAAzB;;AAEA;AAFA,IAGI,CACA,CADA,EAEA,IAFA;;AAKF;AARF,IASI,CACAE,IADA,EAEAG,KAFA,CAZN;;AAkBA;AACA,SAAO,CAAC,KAAD,EAAQG,WAAR,EAAqBH,KAArB,CAAP;AACD,C,EAlED","file":"../../src/hoppfile/load.js","sourcesContent":["/**\n * @file src/utils/load.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport * as cache from '../cache'\nimport { deepEqual } from '../utils'\nimport { stat, readFile } from '../fs'\n\nexport default async file => {\n  // if bad args die\n  if (typeof file !== 'string') {\n    throw new Error('Unknown arguments')\n  }\n\n  // get file stat\n  const lmod = +(await stat(file)).mtime\n\n  // try to load from cache\n  const state = {}\n  ;[state.lmod, state.tasks] = cache.val('_') || []\n\n  if (state.lmod === lmod) {\n    return [true, {}, state.tasks]\n  }\n\n  // load via require\n  const tasks = require(file)\n\n  // figure out which tasks are bust\n  state.tasks = state.tasks || {}\n  const bustedTasks = {}\n\n  // only try checking for single tasks\n  for (let task in tasks) {\n    if (tasks.hasOwnProperty(task) && state.tasks.hasOwnProperty(task)) {\n      const json = tasks[task].toJSON()\n\n      if (!(json instanceof Array) && !deepEqual(json, state.tasks[task])) {\n        bustedTasks[task] = true\n      }\n    }\n  }\n\n  // cache exports\n  cache.val(\n    '_',\n\n    /function|=>/.test(await readFile(require.resolve(file), 'utf8'))\n\n    // if any functions exist, we can't cache the file\n      ? [\n        0,\n        null\n      ]\n\n      // otherwise, cache normally\n      : [\n        lmod,\n        tasks\n      ]\n  )\n\n  // return exports\n  return [false, bustedTasks, tasks]\n}\n"]}